#+TITLE: Introduction to Clojure
#+AUTHOR: John Herrlin
#+DATE: jherrlin@gmail.com


* Overview

  Clojure is a language within the Lisp family of programming languages. There
  are many other languages in the Lisp family. For example Common Lisp, Racket,
  Guile and Emacs Lisp.

  Lisp was born in 1958 at MIT and is one of the oldest programming languages.

  Stackoverflow survey states that Clojure is the [[https://insights.stackoverflow.com/survey/2021#top-paying-technologies][number 1 of the top paying technologies]].

  Clojure is backed by Nubank, the largest financial technology in Latin
  America. Nubank heavily uses Clojure and Datomic (database).

  Rich Hickey is the author of Clojure and have a lot of interesting talks where
  he presents the ideas and mechanics of Clojure.

* Clojure in Växjö

  There are Clojure applications running in production in a few companies. Here
  are a few examples:

  Here are a few of them:
  - KP System
  - HRM
  - Readly
  - Gears of Leo

* Hosted language

  Clojure is a hosted language and can run on many different platforms.

  Here are the most famous ones:
  - JVM (Java, Scala)
  - JavaScript (browsers, Node)
  - Bash (your GNU/Linux shell)
  - Common Language Runtime (C# and .Net framework, Microsoft)

  Code can be shared between this environments. So Clojure code you run on the
  JVM can also run in a web browser.

  Clojure is made for easy interaction with the host language. So it's easy to
  use Java libraries together with Clojure if you work with the JVM. If you are
  a React developer it's easy to use Clojure together with React on the
  frontend.

* Unix philosophy

  There is a norm within the Clojure community to adopt to the Unix philosophy.
  The Unix philosophy states that libraries/programs should do one thing and do
  it well.

  This means that it's not common with framework's in Clojure. Instead you
  compose libraries together to create what you want.

  If you are building a web application. You may need a HTTP server, that's one
  lib. If you need routing that's another. If you need websockets that's another
  lib and so on.

  You often find libraries on GitHub that is "old" and they havent been active
  for a while and in the beginning I thought they were not maintained and
  outdated. Instead they are often "done", they solve a specific problem and
  should not do anything more.

  This can make the learning curve steap as you need to know what you need and
  how to compose the libraries together to fit your need.

* Prefix notation

  In Lisp the function is as always in the first position of the list. The rest
  of the values in the list is the arguments to the function.

  #+BEGIN_SRC python :results output code
    print("Hey Kodkollektivet!")
  #+END_SRC

  #+BEGIN_SRC clojure :results output code
    (print "Hey Kodkollektivet!")
  #+END_SRC

  Now you know Lisp! ;)

* S-expressions

  When you write Lisp code you write lists. Lists starts and ends with =(= =)=.
  Below is a Lisp expressions that calculcates the sum of 4 numbers. The
  function used to sum the numbers is the =+= function.

   #+BEGIN_SRC clojure :results output code
        (+ 1 2 3 4)
     ;; ^^ ^ ^ ^ ^^
     ;; || | | | ||- End of the list
     ;; || | | | |
     ;; || |------ Arguments
     ;; ||- Function to use
     ;; |- Beginning of the list
   #+END_SRC

   The same code in Python could look like this.

   #+BEGIN_SRC python
     return 1 + 2 + 3 + 4
   #+END_SRC

* Lists in lists

  When you write Clojure programs you write lists and compose them together.

  This is how you could write a "Hello World" like function.

  #+BEGIN_SRC clojure :results output code
    (defn say-hi-to [name]
      (println (str "Hello " name "!")))

    (say-hi-to "Kodkollektivet")
  #+END_SRC

  This is the structure, after some time you dont see the parenthesis.
  Here they are removed.
  #+BEGIN_SRC python :results output code
    defn say-hi-to [name]
       println str "Hello " name "!"
  #+END_SRC

* Interactive development
  <<interactive-development>>

  Short feedback loop

  Reacts hot code reloading ALWAYS, EVERYWHERE!

  is a concept where your text editor is tightly coupled with the running
  environment and you can evaluate code on the fly.

  #+BEGIN_SRC artist :results output code
    +----------------+       +---------------------+
    |                |       |                     |
    |  Text editor   |<----->| Running environment |
    |                |       |                     |
    +----------------+       +---------------------+
  #+END_SRC

  The "Running environment" can be a production server, a local JVM or a local
  web browser.
  The environment can be either a running JVM or a web browser.

* Functional programming

  Clojure is not a pure functional language and you are able to do actions. When
  functions do actions the function name is postfixed with an exclamation mark
  (!).

  Action, calculations, data
  Immutable
  Stratified design

* Immutable data structures

  All of Clojures data structures are immutable and thread safe.

  #+BEGIN_SRC clojure :results output code
    (def nr 1)
    (println nr)
    (inc nr)
    (print nr)
  #+END_SRC

  #+BEGIN_SRC clojure :results output code
    (def nr (atom 1))
    (println @nr)
    (swap! nr inc)
    (println @nr)
  #+END_SRC

  Why? Easier to reason about and easier to run in parallel.

  Persistent data structures uses structual sharing (shares memory) to be efficient.

* Local variables

  #+BEGIN_SRC clojure :results output code
    (let [a 10
          b 20]
      (+ a b))
  #+END_SRC

  #+BEGIN_SRC emacs-lisp
    (let ((a 10)
          (b 20))
      (+ a b))
  #+END_SRC

* Where is my for loop?

  They are not there! You dont write for loops in most cases, instead you are
  using =map=, =filter= and =reduce=.

  First class functions

  #+BEGIN_SRC clojure :results output code
    (map inc [1 2 3 4 5])
    ;; => (2 3 4 5 6)

    (filter even? [1 2 3 4 5])
    ;; => (2 4)

    (reduce + 0 [1 2 3 4 5])
    ;; => 15
  #+END_SRC

* Macros

  - Code is data, data is code
  - Homoiconicity

  As Clojure code is data you can manipulate the data to fit your needs.

  Say that you wanna use Postfix notations instead of Prefix.

  #+BEGIN_SRC clojure :results output code
    (" backwards" " am" "I" str)
  #+END_SRC

  #+BEGIN_SRC clojure :results output code
    (defmacro backwards
      [s-expression]
      (reverse s-expression))

    (backwards (" backwards" " am" "I" str))
  #+END_SRC

* DEMO Advent of code, Day 1 2019

  https://adventofcode.com/2019/day/1

  #+BEGIN_SRC text :tangle ./input.txt
    50062
    118298
    106698
    59751
    59461
    144411
    52783
    118293
    148025
    54354
    95296
    68478
    80105
    76390
    75768
    89311
    117129
    127515
    131531
    127565
    77249
    91806
    123811
    123508
    127263
    61076
    82153
    122561
    89117
    116790
    146530
    66706
    56549
    112264
    139250
    87331
    144022
    142052
    125519
    89797
    85148
    125388
    67458
    116066
    74346
    148163
    55477
    146163
    99308
    95653
    122175
    92021
    146532
    109749
    136711
    102321
    114221
    140294
    116718
    127416
    130402
    52239
    125181
    146410
    126339
    147221
    81706
    80131
    140909
    59935
    71878
    64434
    148450
    73037
    90890
    137135
    85992
    137381
    84604
    62524
    64133
    92067
    124269
    132039
    145257
    107367
    62143
    105000
    62124
    55929
    101489
    94728
    85982
    88358
    83275
    132648
    75688
    109263
    146400
    114701
  #+END_SRC

  #+BEGIN_SRC clojure :results output code
    (ns user
      (:require [clojure.string :as str]))


    (defn string->number [s]
      (Integer. s))

    (comment
      (string->number "10")
      )

    (defn calculate-fuel [mass]
      (- (int (/ mass 3)) 2))

    (comment
      (calculate-fuel 14)
      (calculate-fuel 12)
      (- (int (/ 14 3)) 2)
      (- (int (/ 12 3)) 2)
      )

    (defn split-lines [s]
      (str/split s #"\n"))

    (apply +
           (map calculate-fuel
                (map string->number
                     (str/split (slurp "./input.txt") #"\n"))))
    ;; => 3425624

    (->> (slurp "./input.txt")
         (split-lines)
         (map string->number)
         (map calculate-fuel)
         (apply +));; => 3425624
  #+END_SRC
